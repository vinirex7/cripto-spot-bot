
from __future__ import annotations

import os
import sys
import time
import sqlite3
from typing import Any, Dict, List, Optional, Tuple

import yaml

# Uses your existing client
from execution.binance_client import BinanceSpotClient


def interval_to_ms(interval: str) -> int:
    s = interval.strip().lower()
    if s.endswith("m"):
        return int(s[:-1]) * 60_000
    if s.endswith("h"):
        return int(s[:-1]) * 3_600_000
    if s.endswith("d"):
        return int(s[:-1]) * 86_400_000
    raise ValueError(f"Unsupported interval: {interval}")


def ensure_schema(conn: sqlite3.Connection) -> None:
    conn.execute(
        """
        CREATE TABLE IF NOT EXISTS ohlcv (
            symbol TEXT NOT NULL,
            interval TEXT NOT NULL,
            open_time_ms INTEGER NOT NULL,
            open REAL NOT NULL,
            high REAL NOT NULL,
            low REAL NOT NULL,
            close REAL NOT NULL,
            volume REAL NOT NULL,
            PRIMARY KEY (symbol, interval, open_time_ms)
        );
        """
    )
    conn.execute("CREATE INDEX IF NOT EXISTS idx_ohlcv_si_ot ON ohlcv(symbol, interval, open_time_ms);")
    conn.commit()


def upsert(conn: sqlite3.Connection, symbol: str, interval: str, rows: List[List[float]]) -> int:
    if not rows:
        return 0
    payload = []
    for r in rows:
        if len(r) < 6:
            continue
        payload.append((symbol, interval, int(r[0]), float(r[1]), float(r[2]), float(r[3]), float(r[4]), float(r[5])))
    if not payload:
        return 0

    conn.executemany(
        """
        INSERT OR REPLACE INTO ohlcv
        (symbol, interval, open_time_ms, open, high, low, close, volume)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?);
        """,
        payload,
    )
    conn.commit()
    return len(payload)


def normalize_klines(klines: List[List[Any]]) -> List[List[float]]:
    out: List[List[float]] = []
    for k in klines or []:
        try:
            out.append([int(k[0]), float(k[1]), float(k[2]), float(k[3]), float(k[4]), float(k[5])])
        except Exception:
            continue
    return out


def get_latest_open_time(conn: sqlite3.Connection, symbol: str, interval: str) -> Optional[int]:
    cur = conn.cursor()
    cur.execute(
        "SELECT MAX(open_time_ms) FROM ohlcv WHERE symbol=? AND interval=?;",
        (symbol, interval),
    )
    v = cur.fetchone()[0]
    return int(v) if v is not None else None


def load_config(path: str) -> Dict[str, Any]:
    with open(path, "r", encoding="utf-8") as f:
        return yaml.safe_load(f) or {}


def make_client(cfg: Dict[str, Any]) -> BinanceSpotClient:
    keys = (cfg.get("api_keys", {}) or {}).get("binance", {}) or {}
    api_key = (keys.get("api_key") or os.getenv("BINANCE_API_KEY") or "").strip()
    api_secret = (keys.get("api_secret") or os.getenv("BINANCE_API_SECRET") or "").strip()
    binance_cfg = cfg.get("binance", {}) or {}
    return BinanceSpotClient(api_key=api_key, api_secret=api_secret, config=binance_cfg)


def universe(cfg: Dict[str, Any]) -> List[str]:
    u = cfg.get("universe")
    if isinstance(u, list) and u:
        return [str(x).strip().upper() for x in u if str(x).strip()]
    # fallback common place
    u2 = (cfg.get("bot", {}) or {}).get("universe")
    if isinstance(u2, list) and u2:
        return [str(x).strip().upper() for x in u2 if str(x).strip()]
    # last resort
    return ["BTCUSDT", "ETHUSDT"]


def backfill_symbol(
    client: BinanceSpotClient,
    conn: sqlite3.Connection,
    symbol: str,
    interval: str,
    lookback_days: int,
    max_per_call: int = 1000,
) -> int:
    ms = interval_to_ms(interval)
    now_ms = int(time.time() * 1000)

    # Determine start_time
    existing_latest = get_latest_open_time(conn, symbol, interval)
    if existing_latest is None:
        start_ms = now_ms - (lookback_days * 86_400_000)
    else:
        # incremental: start right after last stored candle
        start_ms = existing_latest + ms

    total = 0
    # Loop pulling until "now"
    while start_ms < now_ms:
        klines = client.get_klines(
            symbol=symbol,
            interval=interval,
            limit=max_per_call,
            start_time=start_ms,
            end_time=now_ms,
        )
        rows = normalize_klines(klines)
        if not rows:
            break

        total += upsert(conn, symbol, interval, rows)

        # advance start_ms to last candle + interval
        last_timestamp = int(rows[-1][0])
        new_start_ms = last_timestamp + ms
        
        # Safety: if API returns same last timestamp, avoid infinite loop
        if new_start_ms <= start_ms:
            break
        
        start_ms = new_start_ms

        # small sleep to avoid hammering
        time.sleep(0.2)

    return total


def main() -> int:
    if len(sys.argv) < 2:
        print("Usage: python3 tools/bootstrap_history.py <config.yaml>")
        return 2

    cfg = load_config(sys.argv[1])
    db_path = (cfg.get("storage", {}) or {}).get("sqlite_path", "./bot.db")

    conn = sqlite3.connect(db_path)
    conn.execute("PRAGMA journal_mode=WAL;")
    conn.execute("PRAGMA synchronous=NORMAL;")
    ensure_schema(conn)

    client = make_client(cfg)

    # defaults: 12 months 1d (~420d) and 6 months 1h (~180d)
    lookback_1d_days = int(((cfg.get("history", {}) or {}).get("lookback_1d_days") or 420))
    lookback_1h_days = int(((cfg.get("history", {}) or {}).get("lookback_1h_days") or 180))

    syms = universe(cfg)

    print(f"DB: {db_path}")
    print(f"Universe: {syms}")
    print(f"Backfill: 1d={lookback_1d_days} days | 1h={lookback_1h_days} days")

    total_rows = 0
    for s in syms:
        print(f"\n== {s} ==")
        n1 = backfill_symbol(client, conn, s, "1d", lookback_1d_days)
        print(f"  1d upserts: {n1}")
        n2 = backfill_symbol(client, conn, s, "1h", lookback_1h_days)
        print(f"  1h upserts: {n2}")
        total_rows += (n1 + n2)

    print(f"\nDone. Total upserts: {total_rows}")
    conn.close()
    return 0


if __name__ == "__main__":
    raise SystemExit(main())